# 15장 let, const 키워드와 블록 레벨 스코프
## 15.1 var키워드로 선언한 변수의 문제점
ES5까지 변수를 선언할 수 있는 방법은 `var`키워드 사용이 유일했음
### 🍀 var 키워드의 특징
### 1) 변수 중복 선언 허용
```javascript
var x = 1;
var y = 1;

// var키워드로 선언된 변수는 같은 스코프 내에서 중복 선언 허용
// 초기화문이 있는 변수 선언문 : 자바스크립트 엔진에 의해 var 키워드가 없는 거처럼 동작
var x = 100;

//초기화문 없는 변수 선언문 : 무시
var y;

console.log(x); //100
console.log(y); //1
```
중복 선언시 초기화문 유무에 따라 다르게 작동함
> 📌 이처럼 동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값을 할당한다면 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생함

### 2) 함수 레벨 스코프
`var`키워드로 선언한 변수는 오직 **함수의 코드 블록**만을 `지역 스코프`로 인정한다.<br>
따라서 함수 외부에서 `var`로 선언한 변수는 코드 블록 내에서 선언해도 모두 `전역 변수`가 된다
```javascript
var x = 1;
if (true) {
    //x는 전역 변수다. 이미 선언된 전역 변수가 있으므로 x 변수는 중복 선언됨
    // 이는 의도치 않게 변수값이 변경되는 부작용 발생시킴
    var x = 10;
}

console.log(x); //10
```
for문의 변수 선언문에서 `var`키워드로 선언한 변수도 `전역 변수`가 된다
> 📌 전역 변수를 남발할 가능성을 높임. 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생함

### 3) 변수 호이스팅
`var`키워드로 변수를 선언하면 `변수 호이스팅`에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다<br>
🌟 즉, `변수 호이스팅`에 의해 `var`키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 단 할당문 이전에 변수를 참조하면 undefined 반환
> 📌 변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생하지는 않지만 프로그래밍 흐름상 맞지 않고 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다

---
## 15.2 let 키워드
### 변수 중복 선언 금지
`let` 키워드로 이름이 같은 변수를 중복 선언하면 `문법 에러`가 발생한다

### 블록 레벨 스코프
모든 `코드 블록`(함수, if문, for문, while문, try/catch문 등)을 `지역 스코프`로 인정하는 `블록 레벨 스코프`를 따른다
> 📌 함수도 코드 블록이므로 스코프를 만든다. 이때 함수 내의 코드 블록은 함수 레벨 스코프에 중첩된다<br>
전역 스코프>함수 레벨 스코프>블록 레벨 스코프

### 변수 호이스팅
변수 호이스팅이 발생하지 않는 것처럼 동작한다
```javascript
console.log(x); //참조에러(ReferenceError)
let x = 10;
```
`var` 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 `선언 단계`와 `초기화 단계`가 **한번에** 진행된다.

그러나 `let` 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계` **분리되어** 실행된다<br>
런타임 이전에 자바스크립트 엔진이 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다

초기화 단계가 실행되기 전에 변수에 접근하려고 하면 `참조 에러`
가 발생한다

스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 `일시적 사각지대(Temporal Dead Zone)`라고 부른다

```javascript
// 런타임 이전에 선언 단계가 실행된다.
// 초기화 이전의 일시적 사각지대에서는 변수를 참조할 수 없다
console.log(x); //ReferenceError

let x; //변수 선언문에서 초기화 단계 실행
console.log(x); // undefined

x = 1; //할당문에서 할당 단계 실행
console.log(x); // 1
```
🍀 `let` 키워드로 선언한 변수는 `변수 호이스팅`이 발생하지 않는 것처럼 보이지만 그렇지 않다
```javascript
let x = 1; //전역 변수

{
    console.log(x); //ReferenceError

    let x = 2; //지역 변수
}
```
`let` 키워드의 변수가 `변수 호이스팅`이 발생하지 않는다면 위 예제는 전역 변수 x의 값을 출력해야 한다. 하지만 `let`키워드로 선언한 변수도 여전히 `호이스팅`이 발생하기 때문에 `참조 에러`가 발생한다

자바스크립트는 모든 선언(`var`, `let`, `const`, `function`, `class`...)을 `호이스팅`한다. 단, `let`, `const`, `class`를 사용한 선언문은 `호이스팅`이 발생하지 않는 것처럼 동작한다

### 전역 객체와 let
`var` 키워드로 선언한 `전역 변수`, `전역 함수`, 선언하지 않는 변수에 값을 할당하는 `암묵적 전역`은 `전역 객체`인 `window`의 `프로퍼티`가 된다. `전역 객체`의 `프로퍼티`를 참조할 때 `window`는 생략할 수 있다

```javascript
// 브라우저 환경에서 실행해야함

// 전역 변수
var x = 1;
// 암묵적 변수
y = 2;
// 전역 함수
function(){}

// var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다
console.log(window.x); //1
console.log(x); //1
```
`let`키워드로 선언한 `전역 변수`는 `전역 객체`의 `프로퍼티`가 아니다. 즉, `window.x`처럼 접근할 수 없다. `let` 전역 변수는 보이지 않는 개념적인 블록내에 존재하게 된다

---
## const 키워드
`const` 키워드는 `상수`를 선언하기 위해 사용한다. 하지만 반드시 `상수`를 위해 사용하지는 않음

### 선언과 초기화
**`const`키워드로 선언한 변수는 반드시 선언과 동시에 초기화를 해야한다.**
```javascript
const x = 1;

const y; //SyntaxError 문법 에러
```
`블록 레벨 스코프`를 가지며 `변수 호이스팅`이 발생하지 않는 것처럼 동작한다

### 재할당 금지
**`const` 키워드로 선언한 변수는 재할당이 금지된다**
```javascript
const x = 10;
x = 20;  //TypeError
```

### 상수
**`상수`는 재할당이 금지된 변수를 말한다** 변수는 재할당을 통해 변수 값을 변경할 수 있지만 상수는 재할당이 금지된다

`상수`는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다.

```javascript
// 세전 가격
let preTaxPrice = 100;

// 세후 가격
let afterTaxPrice = preTaxPrice + (preTaxPrice * 0.1);

console.log(afterTaxPrice); //110
```
위 코드에서 사용한 0.1은 어떤 의므로 사용했는지 알 수 없기 때문에 가독성이 좋지 않음. 또한 세율을 의미하는 0.1은 변하지 않는 값임 <br>
🌟 세율을 상수로 정의하면 값의 의미를 파악할 수 있고 변경될 수 없는 고정값으로 사용할 수 있다

`상수`의 이름은 대문자로 선언해 상수임을 명확히 나타낸다<br>
여러 단어로 이루어진 경우 `스네이크 케이스(_)`로 표현하는 것이 일반적임

```javascript
// 세율을 의미하는 0.1은 변경할 수 없는 상수로 사용됨
const TAX_RATE = 0.1;

// 세전 가격
let preTaxPrice = 100;

// 세후 가격
let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);

console.log(afterTaxPrice); //110
```

### const 키워드와 객체
`const` 키워드로 선언된 변수에 원시 값을 할당한 경우 값을 변경할 수 없으나 객체를 할당한 경우 값을 변경할 수 있다.

```javascript
const person = {
    name : 'Lee'
};

// 객체는 변경 가능한 값이다. 따라서 재할당 없이 변경이 가능하다
person.name = 'Kim';

console.log(person); //{ name: 'Kim' }
```
**`const` 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다**<br>
새로운 값을 재할당하는 것은 불가능하지만 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능하다. 이때 객체가 변경되더라도 변수에 할당된 참조 값은 변경되지 않는다

---
## 15.4 `var` vs `let` vs `const`
1) 변수 선언에 기본적으로 `const`사용
2) 재할당이 필요한 경우 `let`사용 (변수의 스코프는 최대한 좁게 만든다)
🌟 `const` 키워드를 사용하면 의도치 않은 재할당을 방지하기 때문에 좀 더 안전함

> 📌  <br>

🌟
🍀
```javascript

```











