# 25장 - 클래스
## 25.1 클래스는 프로토타입의 문법적 설탕인가?
자바스크립트는 프로토타입 기반 객체지향 언어로 클래스가 필요없음

클래스 없이도 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속 구현할 수 있음

클래스는 프로토타입 기반의 객체 생성 메커니즘임(인스턴스를 생성하기 위한 생성자 함수)

**클래스, 생성자 함수 차이점<br>**
|클래스|생성자|
|--|--|
|new연산자 없이 호출하면 에러발생|new연산자 없이 일반 함수로서 호출 가능|
|상속을 지원하는 extends, super키워드 제공|extends, super키워드 제공X|
|호이스팅이 발생하지 않는 것처럼 동작|함수 선언문:함수 호이스팅<br> 함수 표현식:변수 호이스팅 발생|
|암묵적으로 strict mode 지정|암묵적으로 strict mode 지정X|

- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 Enumerable의 값이 false

- 클래스의 상속관계가 더 명료하고 간결함

---
## 25.2 클래스 정의
파스칼 케이스 사용이 일반적
```javascript
//선언문
class Person {}

//표현식
const Person = class {};
```
---
## 25.3 클래스 호이스팅
class는 함수로 평가됨<br>
런타임 이전에 평가되어 함수 객체 생성, 프로토타입도 객체 생성하면서 만들어짐<br>
클래스는 클래스 정의 이전에 참조할 수 없음

---
## 25.4 인스턴스 생성
class는 생성자 함수이며 new연산자와 함께 호출되어 인스턴스 생성함
```javascript
class Person {}

//인스턴스
const me = new Person();
```
---
## 25.5 메서드
클래스에 정의할 수 있는 메서드
- constructor (생성자)
    - 인스턴스 생성,초기화 메서드
    - 메서드로 해석되지 않고 클래스가 평가되어 생성한 함수 객체 코드의 일부가 됨
    - 클래스 내에 최대 1개만 존재 가능
    - 생략 가능(빈 constructor가 암묵적 정의됨)
    - 명시적으로 객체를 반환(return {})하면 암묵적인 this 반환이 무시됨. 단, 원시값 반환시 무시됨
- 프로토타입 메서드
    - 생성자 함수를 사용하여 인스턴스 생성시 프로토타입 메서드 생성
    ```javascript
    function Person(name){
        this.name = name;
    }

    Person.prototype.sayHi = function(){
        console.log("hi");
    };
    ```
    - 클래스에 정의한 메서드는 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 됨
- 정적 메서드
    - 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
    - 인스턴스 프로토타입 체인 상에 클래스가 존재하지 않기 때문에 인스턴스로 클래스의 메서드를 상속받을 수 없음
    - 생성자 함수의 경우 명시적으로 생성자 함수에 메서드 추가해야함 (EX.Person.sayHi)
    - 클래스에서는 static 키워드를 붙이면 됨

```javascript
class Person {
    constructor(name){
        //인스턴스 생성 및 초기화
        this.name = name;
    }
    //프로토타입 메서드
    sayHi(){
        console.log("hi!");
    }
    //정적 메서드
    static sayHello(){
        console.log("hello");
    }
}

const me = new Person('Jeeu');
console.log(me.name);//Jeeu
me.sayHi();//hi!
Person.sayHello();//hello
```
---
### 정적 메서드와 프로토타입 메서드의 차이
1. 자신이 속해 있는 프로토타입 체인이 다름
2. 정적 메서드 : 클래스 호출 / 프로토타입 메서드 : 인스턴스 호출
3. 정적 메서드 : 인스턴스 프로퍼티 참조X / 프로토타입 메서드 : 참조 O

정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수로 정의하지 않고 메서드로 구조화할 때 유용

### 클래스에서 정의한 메서드 특징
1. function 키워드 생략한 메서드 축약 표현 사용
2. 객체 리터럴과 달리 클래스에 메서드를 정의할 때 콤마 필요 없음
3. 암묵적으로 strict mode로 실행됨
4. for ... in 문이나 object.keys 메서드 등으로 열거 불가능
5. 내부 메서드 Construct를 갖지 않는 non-constructor임. new 연산자와 함께 호출 불가능

---
## 25.6 클래스의 인스턴스 생성 과정
1. 인스턴스 생성과 this 바인딩<br>
new 연산자와 함께 클래스 호출시 constructor 내부 코드 실행 전에 암묵적으로 빈 객체 생성됨. 빈 객체는 클래스의 인스턴스임. 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정됨. 인스턴스는 this에 바인딩된다. 따라서 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킴

2. 인스턴스 초기화<br>
this에 바인딩되어 있는 인스턴스에 프로퍼티 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티값을 초기화함

3. 인스턴스 반환<br>
인스턴스가 바인딩된 this가 암묵적으로 반환됨

---
## 25.7 프로퍼티
### 인스턴스 프로퍼티
constructor 내부에서 정의해야함<br>
인스턴스에 프로퍼티가 추가되어 인스턴스 초기화됨<br>
인스턴스 프로퍼티는 항상 public하다.

### 접근자 프로퍼티
자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다<br>
getter, setter 함수<br>
호출하는 것이 아닌 프로퍼티처럼 작동(참조, 할당)

### 클래스 필드 정의 제안
`클래스 필드`란 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리킴

원래 자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있음. 그러나 최신 브라우저 또는 Node.js에는 클래스 필드를 클래스 몸체에 정의 가능

```javascript
class Person {
    //클래스 필드 정의
    name = 'Lee';
}
```
클래스 필드 초기화시 constructor에서 클래스 필드 초기화

그러나 초기화할 필요가 없음. 어차피 constructor 내부에서 클래스 필드를 참조하여 초기값을 할당해야 하기 때문. 이때 클래스가 생성한 인스턴스에 클래스 필드에 해당하는 프로퍼티가 없다면 자동 추가되기 때문이다

모든 클래스 필드는 인스턴스 프로퍼티가 됨

### private 필드
최신브라우저, Node.js에 구현 가능<br>
클래스 몸체에 정의해야함<br>
접근자 프로퍼티를 통해 간접적 접근 가능

```javascript
class Person {
    //private 필드 정의
    #name = '';

    constructor(name) {
        this.#name = name;
    }

    get name(){
        return this.#name.trim();
    }
}

const me = new Person(' Lee ');
console.log(me.name); //Lee
```

## 25.8 상속에 의한 클래스 확장
기존 클래스를 상속받아 새로운 클래스를 확장하여 정의함

클래스는 상속을 통해 기존 클래스를 확장할 수 있는 문법이 기본적으로 제공되지만 생성자 함수는 그렇지 않음

```javascript
class Bird extends Animal{    }
```
서브클래스/수퍼클래스

### super키워드
1. super호출 - 수퍼클래스의 constructor 호출
2. super참조 - 수퍼클래스의 메서드 호출

수퍼클래스의 constructor 내부 추가한 프로퍼티가 변경될경우 서브클래스의 constructor 생략 불가능

이때 수퍼클래스는 super()를 통해 가져옴

🌟 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임함. 이것이 서브클래스의 constructor에서 반드시 super를 호출해야 하는 이유임

### new.target은 서브클래스가 생성하는 인스턴스로 처리됨

### constructor에서 super 호출 전에 this를 참조할 수 없는 이유 : super가 반환한 인스턴스가 this에 바인딩된다. 서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용함.